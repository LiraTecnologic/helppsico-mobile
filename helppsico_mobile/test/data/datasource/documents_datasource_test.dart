import 'dart:convert';
import 'package:flutter_test/flutter_test.dart';
import 'package:helppsico_mobile/core/services/http/generic_http_service.dart';
import 'package:helppsico_mobile/data/datasource/documents_datasource.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'documents_datasource_test.mocks.dart'; // Generated by build_runner

@GenerateMocks([IGenericHttp])
void main() {
  late MockIGenericHttp mockHttp;
  late DocumentsDataSource dataSource;
  // Define baseUrl based on the logic in DocumentsDataSource, assuming non-Android for tests
  const String baseUrl = 'http://localhost:7000'; 

  setUp(() {
    mockHttp = MockIGenericHttp();
    dataSource = DocumentsDataSource(mockHttp);
  });

  final mockDocumentList = [
    {
      "id": "1",
      "title": "Relatório Semanal",
      "description": "Progresso do paciente",
      "date": "2024-03-10T10:00:00.000Z",
      "fileSize": "1.2 MB",
      "fileType": "PDF",
      "type": "RELATORIO",
      "isFavorite": true,
      "patientId": "p1",
      "patientName": "Paciente Alpha",
      "fileUrl": "/docs/relatorio_semanal.pdf"
    }
  ];

  final mockSingleDocument = {
    "id": "3",
    "title": "Atestado",
    "description": "Atestado para afastamento",
    "date": "2024-01-15T00:00:00.000",
    "fileSize": "0.8 MB",
    "fileType": "PDF",
    "type": "ATESTADO",
    "isFavorite": false,
    "patientId": "1",
    "patientName": "João Silva",
    "fileUrl": ""
  };

  group('DocumentsDataSource - getDocuments', () {
    test('should return HttpResponse with documents on success', () async {
      final httpResponse = HttpResponse(statusCode: 200, body: mockDocumentList);
      when(mockHttp.get('$baseUrl/documents')).thenAnswer((_) async => httpResponse);

      final result = await dataSource.getDocuments();

      expect(result.statusCode, 200);
      expect(result.body, mockDocumentList);
      verify(mockHttp.get('$baseUrl/documents')).called(1);
    });

    test('should throw an exception if getDocuments fails (non-200 status)', () async {
      final httpResponse = HttpResponse(statusCode: 500, body: 'Server Error');
      when(mockHttp.get('$baseUrl/documents')).thenAnswer((_) async => httpResponse);

      expect(
        () => dataSource.getDocuments(),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Falha ao obter documentos: 500'))),
      );
    });

    test('should throw an exception if http.get throws', () async {
      when(mockHttp.get('$baseUrl/documents')).thenThrow(Exception('Network error'));

      expect(
        () => dataSource.getDocuments(),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Erro ao conectar com o servidor: Exception: Network error'))),
      );
    });
  });

  group('DocumentsDataSource - uploadDocument', () {
    const filePath = '/path/to/file.pdf';
    final metadata = {'title': 'Test Document', 'patientId': 'p2'};
    final requestBody = {'file_path': filePath, 'metadata': metadata};

    test('should return HttpResponse on successful upload', () async {
      final httpResponse = HttpResponse(statusCode: 201, body: mockSingleDocument);
      when(mockHttp.post('$baseUrl/documents', requestBody)).thenAnswer((_) async => httpResponse);

      final result = await dataSource.uploadDocument(filePath, metadata);

      expect(result.statusCode, 201);
      expect(result.body, mockSingleDocument);
      verify(mockHttp.post('$baseUrl/documents', requestBody)).called(1);
    });

    test('should throw an exception if uploadDocument fails (non-201 status)', () async {
      final httpResponse = HttpResponse(statusCode: 400, body: 'Bad Request');
      when(mockHttp.post('$baseUrl/documents', requestBody)).thenAnswer((_) async => httpResponse);

      expect(
        () => dataSource.uploadDocument(filePath, metadata),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Falha ao enviar documento: 400'))),
      );
    });

    test('should throw an exception if http.post throws for uploadDocument', () async {
      when(mockHttp.post('$baseUrl/documents', requestBody)).thenThrow(Exception('Network error'));

      expect(
        () => dataSource.uploadDocument(filePath, metadata),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Erro ao conectar com o servidor: Exception: Network error'))),
      );
    });
  });

  group('DocumentsDataSource - updateDocument', () {
    const documentId = 'doc123';
    final updateData = {'title': 'Updated Title', 'isFavorite': true};

    test('should return HttpResponse on successful update', () async {
      final httpResponse = HttpResponse(statusCode: 200, body: {...mockSingleDocument, ...updateData});
      when(mockHttp.put('$baseUrl/documents/$documentId', updateData)).thenAnswer((_) async => httpResponse);

      final result = await dataSource.updateDocument(documentId, updateData);

      expect(result.statusCode, 200);
      expect(result.body, {...mockSingleDocument, ...updateData});
      verify(mockHttp.put('$baseUrl/documents/$documentId', updateData)).called(1);
    });

    test('should throw an exception if updateDocument fails (non-200 status)', () async {
      final httpResponse = HttpResponse(statusCode: 404, body: 'Not Found');
      when(mockHttp.put('$baseUrl/documents/$documentId', updateData)).thenAnswer((_) async => httpResponse);

      expect(
        () => dataSource.updateDocument(documentId, updateData),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Falha ao atualizar documento: 404'))),
      );
    });

     test('should throw an exception if http.put throws for updateDocument', () async {
      when(mockHttp.put('$baseUrl/documents/$documentId', updateData)).thenThrow(Exception('Network error'));

      expect(
        () => dataSource.updateDocument(documentId, updateData),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Erro ao conectar com o servidor: Exception: Network error'))),
      );
    });
  });

  group('DocumentsDataSource - deleteDocument', () {
    const documentId = 'docToDelete';

    test('should return HttpResponse on successful delete (204)', () async {
      final httpResponse = HttpResponse(statusCode: 204, body: '');
      when(mockHttp.delete('$baseUrl/documents/$documentId')).thenAnswer((_) async => httpResponse);

      final result = await dataSource.deleteDocument(documentId);

      expect(result.statusCode, 204);
      verify(mockHttp.delete('$baseUrl/documents/$documentId')).called(1);
    });

    test('should throw an exception if deleteDocument fails (non-204 status)', () async {
      final httpResponse = HttpResponse(statusCode: 403, body: 'Forbidden');
      when(mockHttp.delete('$baseUrl/documents/$documentId')).thenAnswer((_) async => httpResponse);

      expect(
        () => dataSource.deleteDocument(documentId),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Falha ao deletar documento: 403'))),
      );
    });

    test('should throw an exception if http.delete throws for deleteDocument', () async {
      // Arrange
      when(mockHttp.delete('$baseUrl/documents/$documentId')).thenThrow(Exception('Network error'));

      // Act & Assert
      expect(
        () => dataSource.deleteDocument(documentId),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Erro ao conectar com o servidor: Exception: Network error'))),
      );
    });
  });

  group('DocumentsDataSource - toggleFavorite', () {
    const documentId = 'docToFavorite';

    test('should return HttpResponse on successful toggleFavorite', () async {
      // Arrange
      final updatedDocument = {...mockSingleDocument, 'isFavorite': !(mockSingleDocument['isFavorite'] as bool)};
      final httpResponse = HttpResponse(statusCode: 200, body: updatedDocument);
      when(mockHttp.put('$baseUrl/documents/$documentId/toggle-favorite', {})).thenAnswer((_) async => httpResponse);

      // Act
      final result = await dataSource.toggleFavorite(documentId);

      // Assert
      expect(result.statusCode, 200);
      expect(result.body, updatedDocument);
      verify(mockHttp.put('$baseUrl/documents/$documentId/toggle-favorite', {})).called(1);
    });

    test('should throw an exception if toggleFavorite fails (non-200 status)', () async {
      // Arrange
      final httpResponse = HttpResponse(statusCode: 500, body: 'Server Error');
      when(mockHttp.put('$baseUrl/documents/$documentId/toggle-favorite', {})).thenAnswer((_) async => httpResponse);

      // Act & Assert
      expect(
        () => dataSource.toggleFavorite(documentId),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Falha ao atualizar favorito: 500'))),
      );
    });

    test('should throw an exception if http.put throws for toggleFavorite', () async {
      // Arrange
      when(mockHttp.put('$baseUrl/documents/$documentId/toggle-favorite', {})).thenThrow(Exception('Network error'));

      // Act & Assert
      expect(
        () => dataSource.toggleFavorite(documentId),
        throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Erro ao conectar com o servidor: Exception: Network error'))),
      );
    });
  });

   test('baseUrl getter should return correct url for non-Android', () {
    // This test relies on the default `bool.fromEnvironment('dart.vm.android')` being false in test environment.
    expect(dataSource.baseUrl, 'http://localhost:7000');
  });

  // To test the Android URL, you would need to set 'dart.vm.android' to true during the test run,
  // which is typically done via environment variables or specific test configurations.
  // Example (conceptual, actual mechanism depends on test runner):
  // test('baseUrl getter should return correct url for Android', () {
  //   // Mock or set bool.fromEnvironment('dart.vm.android', defaultValue: true)
  //   final androidDataSource = DocumentsDataSource(mockHttp, isAndroidOverride: true); // Hypothetical constructor change
  //   expect(androidDataSource.baseUrl, 'http://10.0.2.2:7000');
  // });

}