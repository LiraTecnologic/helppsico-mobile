import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:helppsico_mobile/core/services/storage/secure_storage_service.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';

import 'secure_storage_service_test.mocks.dart'; // Generated by build_runner

@GenerateMocks([FlutterSecureStorage])
void main() {
  late MockFlutterSecureStorage mockFlutterSecureStorage;
  late SecureStorageService secureStorageService;

  setUp(() {
    mockFlutterSecureStorage = MockFlutterSecureStorage();
    secureStorageService = SecureStorageService(storage: mockFlutterSecureStorage);
  });

  const String testToken = 'test_token';
  const String testUserData = '{"name":"Test User","id":"123"}';
  const String tokenKey = 'jwt_token';
  const String userDataKey = 'user_data';

  group('SecureStorageService - Token Management', () {
    test('saveToken should call write on FlutterSecureStorage', () async {
      // Arrange
      when(mockFlutterSecureStorage.write(key: tokenKey, value: testToken))
          .thenAnswer((_) async => Future.value());

      // Act
      await secureStorageService.saveToken(testToken);

      // Assert
      verify(mockFlutterSecureStorage.write(key: tokenKey, value: testToken)).called(1);
    });

    test('saveToken should throw exception if storage write fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.write(key: tokenKey, value: testToken))
          .thenThrow(Exception('Storage error'));

      // Act & Assert
      expect(() => secureStorageService.saveToken(testToken), 
             throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to save token: Exception: Storage error'))));
    });

    test('getToken should call read on FlutterSecureStorage and return token', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: tokenKey)).thenAnswer((_) async => testToken);

      // Act
      final token = await secureStorageService.getToken();

      // Assert
      expect(token, testToken);
      verify(mockFlutterSecureStorage.read(key: tokenKey)).called(1);
    });

    test('getToken should return null if no token is stored', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: tokenKey)).thenAnswer((_) async => null);

      // Act
      final token = await secureStorageService.getToken();

      // Assert
      expect(token, isNull);
    });

    test('getToken should throw exception if storage read fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: tokenKey)).thenThrow(Exception('Storage error'));

      // Act & Assert
      expect(() => secureStorageService.getToken(), 
             throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to retrieve token: Exception: Storage error'))));
    });

    test('hasToken should return true if token exists and is not empty', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: tokenKey)).thenAnswer((_) async => testToken);

      // Act
      final hasToken = await secureStorageService.hasToken();

      // Assert
      expect(hasToken, isTrue);
    });

    test('hasToken should return false if token is null', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: tokenKey)).thenAnswer((_) async => null);

      // Act
      final hasToken = await secureStorageService.hasToken();

      // Assert
      expect(hasToken, isFalse);
    });

    test('hasToken should return false if token is empty', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: tokenKey)).thenAnswer((_) async => '');

      // Act
      final hasToken = await secureStorageService.hasToken();

      // Assert
      expect(hasToken, isFalse);
    });

    test('hasToken should return false if storage read fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: tokenKey)).thenThrow(Exception('Storage error'));

      // Act
      final hasToken = await secureStorageService.hasToken();

      // Assert
      expect(hasToken, isFalse); // As per current implementation, it catches the exception and returns false.
    });

    test('deleteToken should call delete on FlutterSecureStorage', () async {
      // Arrange
      when(mockFlutterSecureStorage.delete(key: tokenKey)).thenAnswer((_) async => Future.value());

      // Act
      await secureStorageService.deleteToken();

      // Assert
      verify(mockFlutterSecureStorage.delete(key: tokenKey)).called(1);
    });

    test('deleteToken should throw exception if storage delete fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.delete(key: tokenKey)).thenThrow(Exception('Storage error'));

      // Act & Assert
      expect(() => secureStorageService.deleteToken(), 
             throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to delete token: Exception: Storage error'))));
    });
  });

  group('SecureStorageService - UserData Management', () {
    test('saveUserData should call write on FlutterSecureStorage', () async {
      // Arrange
      when(mockFlutterSecureStorage.write(key: userDataKey, value: testUserData))
          .thenAnswer((_) async => Future.value());

      // Act
      await secureStorageService.saveUserData(testUserData);

      // Assert
      verify(mockFlutterSecureStorage.write(key: userDataKey, value: testUserData)).called(1);
    });

    test('saveUserData should throw exception if storage write fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.write(key: userDataKey, value: testUserData))
          .thenThrow(Exception('Storage error'));

      // Act & Assert
      expect(() => secureStorageService.saveUserData(testUserData), 
             throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to save user data: Exception: Storage error'))));
    });

    test('getUserData should call read on FlutterSecureStorage and return data', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: userDataKey)).thenAnswer((_) async => testUserData);

      // Act
      final userData = await secureStorageService.getUserData();

      // Assert
      expect(userData, testUserData);
      verify(mockFlutterSecureStorage.read(key: userDataKey)).called(1);
    });

    test('getUserData should return null if no data is stored', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: userDataKey)).thenAnswer((_) async => null);

      // Act
      final userData = await secureStorageService.getUserData();

      // Assert
      expect(userData, isNull);
    });

    test('getUserData should throw exception if storage read fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.read(key: userDataKey)).thenThrow(Exception('Storage error'));

      // Act & Assert
      expect(() => secureStorageService.getUserData(), 
             throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to retrieve user data: Exception: Storage error'))));
    });

    test('deleteUserData should call delete on FlutterSecureStorage', () async {
      // Arrange
      when(mockFlutterSecureStorage.delete(key: userDataKey)).thenAnswer((_) async => Future.value());

      // Act
      await secureStorageService.deleteUserData();

      // Assert
      verify(mockFlutterSecureStorage.delete(key: userDataKey)).called(1);
    });

    test('deleteUserData should throw exception if storage delete fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.delete(key: userDataKey)).thenThrow(Exception('Storage error'));

      // Act & Assert
      expect(() => secureStorageService.deleteUserData(), 
             throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to delete user data: Exception: Storage error'))));
    });
  });

  group('SecureStorageService - Clear All', () {
    test('clearAll should call deleteAll on FlutterSecureStorage', () async {
      // Arrange
      when(mockFlutterSecureStorage.deleteAll()).thenAnswer((_) async => Future.value());

      // Act
      await secureStorageService.clearAll();

      // Assert
      verify(mockFlutterSecureStorage.deleteAll()).called(1);
    });

    test('clearAll should throw exception if storage deleteAll fails', () async {
      // Arrange
      when(mockFlutterSecureStorage.deleteAll()).thenThrow(Exception('Storage error'));

      // Act & Assert
      expect(() => secureStorageService.clearAll(), 
             throwsA(isA<Exception>().having((e) => e.toString(), 'message', contains('Failed to clear all data: Exception: Storage error'))));
    });
  });

  test('SecureStorageService constructor uses default FlutterSecureStorage if none provided', () {
    // This test is a bit conceptual for mocking, as we can't easily verify the instance type
    // without a more complex setup or by checking if the methods are callable (which they would be).
    // The main point is that the constructor should not throw an error.
    expect(() => SecureStorageService(), returnsNormally);
  });
}