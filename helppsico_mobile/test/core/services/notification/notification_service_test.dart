import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:helppsico_mobile/core/services/notification/notification_service.dart';
import 'package:helppsico_mobile/domain/entities/notification_entity.dart';
import 'package:helppsico_mobile/presentation/viewmodels/cubit/notifications_cubit.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'package:get_it/get_it.dart';

import 'notification_service_test.mocks.dart'; // Generated by build_runner

// Mock NotificationsCubit
@GenerateMocks([NotificationsCubit])
void main() {
  late MockNotificationsCubit mockNotificationsCubit;
  late NotificationService notificationService;
  final getIt = GetIt.instance;

  setUp(() {
    // Clear all previous registrations from GetIt
    getIt.reset();
    
    mockNotificationsCubit = MockNotificationsCubit();
    
    // Register the mock cubit with GetIt before NotificationService is instantiated
    getIt.registerSingleton<NotificationsCubit>(mockNotificationsCubit);
    
    // Instantiate NotificationService. It should pick up the mock from GetIt.
    notificationService = NotificationService();
  });

  tearDown(() {
    getIt.reset();
  });

  group('NotificationService Tests', () {
    final testNotificationEntity = NotificationEntity(
      id: 1,
      title: 'Test Title',
      body: 'Test Body',
      scheduledDate: DateTime.now(),
      payload: 'Test Payload',
    );

    test('constructor should get NotificationsCubit from GetIt if registered', () {
      // Assert
      expect(notificationService.notificationsCubit, equals(mockNotificationsCubit));
    });

    test('init should call loadNotifications on NotificationsCubit', () {
      // Arrange
      when(mockNotificationsCubit.loadNotifications()).thenAnswer((_) async {});

      // Act
      notificationService.init();

      // Assert
      verify(mockNotificationsCubit.loadNotifications()).called(1);
    });

    test('saveNotification should create NotificationEntity and call addNotification on NotificationsCubit', () async {
      // Arrange
      when(mockNotificationsCubit.addNotification(any)).thenAnswer((_) async {});

      // Act
      await notificationService.saveNotification(
        id: testNotificationEntity.id,
        title: testNotificationEntity.title,
        body: testNotificationEntity.body,
        scheduledDate: testNotificationEntity.scheduledDate,
        payload: testNotificationEntity.payload,
      );

      // Assert
      verify(mockNotificationsCubit.addNotification(argThat(
        isA<NotificationEntity>()
            .having((e) => e.id, 'id', testNotificationEntity.id)
            .having((e) => e.title, 'title', testNotificationEntity.title)
            .having((e) => e.body, 'body', testNotificationEntity.body)
            .having((e) => e.scheduledDate, 'scheduledDate', testNotificationEntity.scheduledDate)
            .having((e) => e.payload, 'payload', testNotificationEntity.payload),
      ))).called(1);
    });

    test('onNotificationReceived should print payload (or handle as implemented)', () {
      // Arrange
      final notificationResponse = NotificationResponse(
        payload: 'test_payload_from_response',
        notificationResponseType: NotificationResponseType.selectedNotification,
      );
      // This method currently only prints. We can't directly test print output easily without
      // more complex setups (like overriding print). So, we'll just call it to ensure no exceptions.
      // If it had more logic, we'd test that logic.

      // Act & Assert
      expect(() => notificationService.onNotificationReceived(notificationResponse), returnsNormally);
      // To verify print, you might need to use a package or a custom Zone with print overridden.
      // For now, we just ensure it runs.
    });

    test('clearAllNotifications should call clearNotifications on NotificationsCubit', () async {
      // Arrange
      when(mockNotificationsCubit.clearNotifications()).thenAnswer((_) async {});

      // Act
      await notificationService.clearAllNotifications();

      // Assert
      verify(mockNotificationsCubit.clearNotifications()).called(1);
    });

    test('NotificationService factory constructor returns a singleton instance', () {
        final instance1 = NotificationService();
        final instance2 = NotificationService();
        expect(identical(instance1, instance2), isTrue);
    });

    test('NotificationService._internal constructor registers NotificationsCubit if not already registered', () {
        // Reset GetIt to ensure NotificationsCubit is not registered
        getIt.reset();
        // Manually create a new cubit instance for this test case
        final newCubitInstance = NotificationsCubit(); 
        // Register it to simulate it being available for the next internal constructor call
        getIt.registerSingleton<NotificationsCubit>(newCubitInstance); 

        // Call internal constructor indirectly via factory
        final service = NotificationService(); 

        // Check if the service's cubit is the one we registered
        expect(identical(service.notificationsCubit, newCubitInstance), isTrue);

        // Check if GetIt has the cubit registered
        expect(getIt.isRegistered<NotificationsCubit>(), isTrue);
        expect(identical(getIt<NotificationsCubit>(), newCubitInstance), isTrue);
    });

     test('NotificationService._internal constructor creates and registers NotificationsCubit if not registered', () {
        // Reset GetIt to ensure NotificationsCubit is not registered
        getIt.reset();
        
        // Call internal constructor indirectly via factory
        final service = NotificationService(); 

        // Check if GetIt has the cubit registered
        expect(getIt.isRegistered<NotificationsCubit>(), isTrue);
        // Check if the service's cubit is the one that was created and registered
        expect(identical(service.notificationsCubit, getIt<NotificationsCubit>()), isTrue);
    });

  });
}